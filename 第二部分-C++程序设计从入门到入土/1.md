<center> <font face = "宋体" size = 10> 第二部分 C++程序设计


本部分内容主要包括：
- [ ] 程序基本概念
- [ ] 常用数据类型
- [ ] 程序基本语句及基本程序设计
- [ ] 基本运算
- [ ] 函数与递归
- [ ] 指针思想
- [ ] 文件读写
- [ ] 类
- [ ] STL

------



# 程序基本概念



###  对于程序的理解

既然是要学习程序设计竞赛，那么我们要先了解一下什么是程序。

程序（program）可以看作一系列可执行指令的集合，这些指令主要包括：

- 输入（Input）：获取数据；
- 输出（Output）：把数据显示到屏幕上或存入一个文件等；
- 运算：执行最基本的运算（基本数学运算如加减乘除、位运算等）和数据存储；
- 判断和分支：判断某个条件，根据判断结果执行不同命令；
- 循环：重复执行一系列操作。

以上这些指令的详解将会在本部分后续章节给出。

比如说我们思考一个非常简单的例子：

> 输入两个数 $a, b$ ，交换 $a$ 和 $b$ 的值后输出。

那么我们这个程序可以分为三步：

1. 输入：输入 $a$ 和 $b$
2. 运算：新建一个变量 $c$ ，令 $c$ 赋值为 $a$；接着，令 $a = b, b = c$；
3. 输出：输出运算后的 $a$ 和 $b$。

其实我们看到那些高大上的代码本质上也是由一个个可执行的指令组合而成。其实很多时候我们抱怨这题一秒钟切但是代码实现好难，并不是因为这题毒瘤还是什么的，还是因为我们自己的思路不够清晰。每一步的命令就这么几种，理清思路，题目自然能迎刃而解。



### 一些基本概念



------

# 数据类型

什么是数据类型？数据类型指的是可以在程序中存储和操作的值的类型，每种编程语言都有其支持的数据类型，不同的数据类型用来存储不同的数据，例如文本、数值、图像等。

C++语言不仅为我们提供了 `int，double `等基本数据类型，还为我们提供了如数组、结构体等构造类型，以及指针类型、空类型等其他数据类型。



## 基本数据类型

常用基本数据类型主要有以下几种：

##### 整型：

整型变量表示的是整数类型的数据。C++中能够表示整型的类型有以下几种方式，区别在于所占内存空间不同：

| 数据类型             | 占用空间                                            | 取值范围              |
| :------------------- | :-------------------------------------------------- | :-------------------- |
| short（短整数）      | 2字节                                               | $-2^{15}$ ~$2^{15}-1$ |
| int（整型）          | 4字节                                               | $-2^{31}$ ~$2^{31}-1$ |
| long（长整型）       | Windows为4字节，Linux为4字节（32位），8字节（64位） | $-2^{31}$ ~$2^{31}-1$ |
| long long (长长整型) | 8字节                                               | $-2^{63}$ ~$2^{63}-1$ |

数据在计算机中的存储都遵循我们在第一部分所提到的以补码形式存储，那么我们想想如果我们要存储的这个数超出了这个数据类型的存储范围会怎么样呢？

我们可以试着定义一个 `int` 类型的数，赋值为 $2^{31}$ ，再将其输出，我们会发现它会输出 $-2147483648$，也就是 $-2^{31}$ ，这是为什么呢？将 $2^{31}$ 用补码表示出来，即为 $010000...(1后面有31个0)$ ，这一共有 $33$ 位，然而 int 类型只能存储 $32$ 位，所以计算机只能保留后面那 $32$ 位而舍后面31去前面的，那么现在就成了 $1000...(1后面31个0)$ ，而这其实是 $-2^{31}$ 的补码表示。

这是对于有符号整数的，那么对于无符号整数 （如 `unsigned int long long`）呢？无符号整数自然是不必考虑符号的问题，若是溢出依然是保留后面几位，如 `unsigned long long`  溢出其实就相当于对 $2^{64}$ 取模。

##### sizeof关键字

- 作用：利用sizeof关键字可以统计数据类型所占内存大小

- 语法

  ```cpp
  sizeof（数据类型 / 变量）
  ```

- 示例：

  ```cpp
  int main() {
    short a = 10;
    int b =11;
    long c = 12;
    long long d = 13;
    cout << "short 类型所占内存空间为：" << sizeof(short) << endl;
    cout << "int 类型所占内存空间为：" << sizeof(int) << endl;
    cout << "long 类型所占内存空间为：" << sizeof(long) << endl;
    cout << "long long 类型所占内存空间为：" << sizeof(long long) << endl;
    system("pause");
    system("cls");   //清屏操作
    return 0;
  }
  ```

$sizeof$在程序设计竞赛中常用的一个地方是对于整个数组的初始化：

```cpp
memset(a, 0, sizeof(a));
```

##### 浮点型

浮点型，即为小数类型。一般浮点数数据类型由符号位、指数位、尾数位组成。浮点数的范围由符号位决定，精度则由指数位决定。

**float**：占32位，其中符号位 $1bit$ ，指数位 $8bits$，尾数位 $23bits$，范围 $-3.40E+38$ ~ $+3.40E+38$。

**double**：占64位，其中符号位 $1bits$，指数位 $11bits$，尾数位 $53bits$，范围 $-1.79E+308$ ~ $+1.79E+308$

 **long double**：占96位，范围：$ 1.18973e+4932$ ~ $3.3621e-4932$。特别注意，long double在使用库函数时要在函数后面加个l。

默认情况下输出小数时都是输出 6 位有效数字

##### 字符型

字符型变量用于显示单个字符。

```cpp
char c = 'a';
```

需要注意是，单个字符用单引号。

字符型变量只占 1 字节，存储时并不是直接存储这个字符而是存储这个字符的 ASCII 码。

ASCII (American Standard Code for Information Interchange)：美国信息交换标准代码是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是最通用的信息交换标准，并等同于国际标准 ISO/IEC 646，ASCII码到目前为止共定义了128个字符，正好是 1 字节，这就是字符型只占 1 字节的原因。

完整的ASCII码如下：

| **ASCII值** | **控制字符** | **ASCII值** | **控制字符** | **ASCII值** | **控制字符** | **ASCII值** | **控制字符** |
| ----------- | ------------ | ----------- | ------------ | ----------- | ------------ | ----------- | ------------ |
| 0           | NUL          | 32          | (space)      | 64          | @            | 96          | 、           |
| 1           | SOH          | 33          | ！           | 65          | A            | 97          | a            |
| 2           | STX          | 34          | ”            | 66          | B            | 98          | b            |
| 3           | ETX          | 35          | #            | 67          | C            | 99          | c            |
| 4           | EOT          | 36          | $            | 68          | D            | 100         | d            |
| 5           | ENQ          | 37          | %            | 69          | E            | 101         | e            |
| 6           | ACK          | 38          | &            | 70          | F            | 102         | f            |
| 7           | BEL          | 39          | '            | 71          | G            | 103         | g            |
| 8           | BS           | 40          | (            | 72          | H            | 104         | h            |
| 9           | HT           | 41          | )            | 73          | I            | 105         | i            |
| 10          | LF           | 42          | *            | 74          | J            | 106         | j            |
| 11          | VT           | 43          | +            | 75          | K            | 107         | k            |
| 12          | FF           | 44          | ,            | 76          | L            | 108         | l            |
| 13          | CR           | 45          | -            | 77          | M            | 109         | m            |
| 14          | SO           | 46          | .            | 78          | N            | 110         | n            |
| 15          | SI           | 47          | /            | 79          | O            | 111         | o            |
| 16          | DLE          | 48          | 0            | 80          | P            | 112         | p            |
| 17          | DCI          | 49          | 1            | 81          | Q            | 113         | q            |
| 18          | DC2          | 50          | 2            | 82          | R            | 114         | r            |
| 19          | DC3          | 51          | 3            | 83          | X            | 115         | s            |
| 20          | DC4          | 52          | 4            | 84          | T            | 116         | t            |
| 21          | NAK          | 53          | 5            | 85          | U            | 117         | u            |
| 22          | SYN          | 54          | 6            | 86          | V            | 118         | v            |
| 23          | TB           | 55          | 7            | 87          | W            | 119         | w            |
| 24          | CAN          | 56          | 8            | 88          | X            | 120         | x            |
| 25          | EM           | 57          | 9            | 89          | Y            | 121         | y            |
| 26          | SUB          | 58          | :            | 90          | Z            | 122         | z            |
| 27          | ESC          | 59          | ;            | 91          | [            | 123         | {            |
| 28          | FS           | 60          | <            | 92          | \            | 124         | \|           |
| 29          | GS           | 61          | =            | 93          | ]            | 125         | }            |
| 30          | RS           | 62          | >            | 94          | ^            | 126         | ~            |
| 31          | US           | 63          | ?            | 95          | —            | 127         | DEL          |

其中，前面的 31 个字符都是控制字符，用于控制打印机等一些外围设备，我们一般不需理解它是什么意思，感兴趣的同学可以自行上网查阅。

##### 字符串型

作用：用于表示一串字符

注意：字符串值需要用双引号 "" 包含起来，与字符使用的单引号 '' 做区分。

C风格字符串：`char 变量名[] = "字符串值"；`

示例：

```cpp
int main() {
  char str1[] = "hello-world";   //C风格字符串需要在变量名后面加中括号 []
  cout << str1 << endl;
  system("pause");
  return 0;
}
```

C++风格字符串：string 变量名 = "字符串值"；

示例：

```cpp
#include<string>   //用C++风格字符串时候，要引用这个头文件
int main() {
  string str2 = "hello-world";
  cout << str2 << endl;
  system("pause");
  return 0;
}
```

##### bool型

作用：布尔数据类型代表真或假的值

`bool`类型只有两个值：true --- 真（本质是1；false --- 假（本质是0）

`bool`类型占1个字节大小

```cpp
int a = 1;
bool flag = (a > 0);
cout << flag;
//输出1
```

我们已经知道，bool类型只需要两个值：1和0，这样的话应该只占1位，然而实际上`bool`型却占了4位，剩下的 126 个值是干什么的呢？实际上，这并没有什么用，反而占了许多空间。那么对于有的题，空间比较紧张，如果我们用 bool 型而浪费了许多空间而 MLE(Time Limit Exceeded)，这岂不是一件可能遗恨千古的事吗（尤其是在考场上）。

那么，`bitset`便派上了用场。

C++的 bitset 在 bitset 头文件中，它是一种类似数组的结构，它的每一个元素只能是０或１，每个元素仅用１bit空间。

由于内存地址是按字节即 `byte` 寻址，而非比特 `bit`，一个 `bool` 类型的变量，虽然只能表示 `0/1`, 但是也占了 1 byte 的内存。

`bitset` 就是通过固定的优化，使得一个字节的八个比特能分别储存 8 位的 `0/1`。

对于一个 4 字节的 `int` 变量，在只存 `0/1` 的意义下，`bitset` 占用空间只是其$\frac{1}{32}$，计算一些信息时，所需时间也是其$\frac{1}{32}$。

bitset常用构造函数有四种，如下

```cpp
    bitset<4> bitset1;　　//无参构造，长度为４，默认每一位为０

    bitset<8> bitset2(12);　　//长度为８，二进制保存，前面用０补充

    string s = "100101";
    bitset<10> bitset3(s);　　//长度为10，前面用０补充
    
    char s2[] = "10101";
    bitset<13> bitset4(s2);　　//长度为13，前面用０补充

    cout << bitset1 << endl;　　//0000
    cout << bitset2 << endl;　　//00001100
    cout << bitset3 << endl;　　//0000100101
    cout << bitset4 << endl;　　//0000000010101
```

那么现在我们就可以将 `bitset` 当作一个`bool`数组用了，我们来看看改动这个“数组”的值的操作：

- `operator []`: 访问其特定的一位。
- `operator ==/!=`: 比较两个 `bitset` 内容是否完全一样。
- `operator &/&=/|/| =/^/^=/~`: 进行按位与/或/异或/取反操作。

其他操作我们后面在详细讲解`bitset` 时会提到。



## 构造类型

构造类型，即由基本数据类型组合而来。

### 数组

概述：数组时一个集合，里面存放了相同类型的数据元素

特点：

  - 数组中的每个数据元素都是相同的数据类型
  - 数组是由连续的内存位置组成的

#### 一维数组

##### 一维数组定义方式

  一维数组定义的三种方式：

  - 数据类型 数组名[数组长度];

  - 数据类型 数组名[数组长度] = {值1,值2,...};

  - 数据类型 数组名[] = {值1,值2,...};

- 示例：

  ```cpp
  using namespace std;
  int main(){
    //数据类型 数组名[数组长度];
    int arr[5];
    //给数组中的元素进行赋值
    //数组元素的下标时从0开始索引的
    arr[0] = 10;
    arr[0] = 20;
    arr[0] = 30;
    arr[0] = 40;
    arr[0] = 50;
    //访问数据元素
    cout << arr[0] << endl;
  
    //数据类型 数组名[数组长度] = {值1,值2,...};
    //如果在初始化数据的时候，没有全部填写完，会用0填补剩余数据
    int arr2[5] = {100,200,300};
    //利用循环输出数组中的元素
    for (int i = 0; i < 5; i++){
      cout << arr2[i] << endl;
    }
  
    //数据类型 数组名[] = {值1,值2,...};
    //定义数组的时候，必须有初始的长度
    int arr3[] = {90,80,70,60,50,40,30,20,10};
    for (int j = 0; j < 9; j++){
      cout << arr3[j] << endl;
    }
  
    system("pause");
    return 0;
  }
  ```

  注意1：数组名的命名规范与变量名命名规范一致，不要和变量重名
  注意2：数组中下标是从0开始索引

##### 一维数组数组名

  一维数组名称的用途：

  - 可以统计整个数组在内存中的长度

    ```cpp
    sizeof(arr)
    sizeof(arr[0])
    ```

  - 可以获取数组在内存中的首地址

    ```cpp
    cout << arr << endl;
    ```

- 示例：

  ```cpp
  using namespace std;
  int main(){
  
    //可以统计整个数组在内存中的长度
    int arr[10] = {1,2,3,4,5,6,7,8,9,10};
    cout << "整个数组占用内存空间为：" << sizeof(arr) << endl;
    cout << "每个元素占用内存空间：" << sizeof(arr[0]) << endl;
    cout << "数组中元素个数为：" << sizeof(arr) / sizeof(arr[0]) << endl;
  
    //可以获取数组在内存中的首地址
    cout << "数组首地址为：" << arr << endl;    //输出十六进制的内存地址
    cout << "数组首地址为：" << (int)arr << endl; //输出十进制的内存地址
    cout << "数组中第一个元素地址为：" << (int)&arr[0] << endl; 
  
    //数组名是常量，不可以进行赋值操作
  
    system("pause");
    return 0;
  }
  ```

  案例：五只小猪称重
  要求：在一个数组中记录五只小猪的体重，找出并打印最重的小猪体重。

  ```cpp
  using namespace std;
  int main(){
  
    //创建五只小猪体重的数组
    int arr[5] = {300,350,200,400,250};
  
    //从数组中找到最大值
    int max = 0;    //先认定一个最大值为0
  
    for (int i = 0; i < 5; i++){
      //如果访问的数组中的元素比 max 的值还要大，更新 max 值
      if (arr[i] > max){
        max = arr[i]; 
      }
    }
  
    //打印最大值
    cout << "最重的小猪体重为：" << max << endl;
  
    system("pause");
    return 0;
  }
  ```

  案例2：数组元素逆置
  要求：请声明一个5元素的数组，并且将元素逆置

  ```cpp
  using namespace std;
  int main(){
  
    //实现数组元素逆置
    //创建数组
    int arr[5] = {1,3,2,5,4};
    cout << "数组逆置前：" << endl;
    for (int i = 0; i <5; i++){
      cout << arr[i] << endl;
    }
  
    //实现逆置
    //记录起始下标位置
    int start = 0;
  
    //记录结束下标位置
    int end = sizeof(arr)/sizeof(arr[0]) - 1; //末尾元素下标
  
    while (start < end) {
  
    //起始下标与结束下标的元素互换
    int temp = arr[start];
    arr[start] = arr[end];
    arr[end] = temp;
  
    //起始位置++，结束位置--。下标更新
    start++;
    end--;
    }
    //循环执行操作，直到起止位置 >= 结束位置
    cout << "数组逆置后：" << endl;
    for (int i = 0; i <5; i++){
      cout << arr[i] << endl;
    }
  
    system("pause");
    return 0;
  }
  ```

#### 二维数组

二维数组就是在一维数组上多加一个维度

二维数组定义方式：

  - 数据类型 数组名[行数][列数];

  - 数据类型 数组名[行数][列数] = {{数据1,数据2} , {数据3,数据4}};

  - 数据类型 数组名[行数][列数] = {数据1,数据2,数据3,数据4};

  - 数据类型 数组名[  ][列数] = {数据1,数据2,数据3,数据4};

示例：

```cpp
using namespace std;
int main(){
  
  //数据类型 数组名[行数][列数];
  int arr[2][3];
  arr[0][0] = 1;
  arr[0][1] = 2;
  arr[0][2] = 3;
  arr[1][0] = 4;
  arr[1][1] = 5;
  arr[1][2] = 6;

  //输出二维数组元素值
  for (int i = 0; i < (sizeof(arr)/sizeof(arr[0][0])/3); i++){
    for (int j = 0; j < (sizeof(arr)/sizeof(arr[0][0])/2); j++){
      cout << arr[i][j] << endl;
    }
}
    //数据类型 数组名[行数][列数] = {{数据1,数据2} , {数据3,数据4}}; 
    int arr2[2][3] = {
      {1,2,3},
      {4,5,6}
    };
    for (int i = 0; i < (sizeof(arr2)/sizeof(arr2[0][0])/3); i++){
      for (int j = 0; j < (sizeof(arr2)/sizeof(arr2[0][0])/2); j++){
        cout << arr2[i][j] << " " ;
      }
      cout << endl;
    }

    //数据类型 数组名[行数][列数] = {数据1,数据2,数据3,数据4};
    int arr3[2][3] = {1,2,3,4,5,6};
    for (int i = 0; i < (sizeof(arr3)/sizeof(arr3[0][0])/3); i++){
      for (int j = 0; j < (sizeof(arr3)/sizeof(arr3[0][0])/2); j++){
        cout << arr3[i][j] << " " ;
      }
      cout << endl;
    }

    //数据类型 数组名[  ][列数] = {数据1,数据2,数据3,数据4};
    int arr4[][3] = {1,2,3,4,5,6};
    for (int i = 0; i < (sizeof(arr4)/sizeof(arr4[0][0])/3); i++){
      for (int j = 0; j < (sizeof(arr4)/sizeof(arr4[0][0])/2); j++){
        cout << arr4[i][j] << " " ;
      }
      cout << endl;
    }

    system("pause");
    return 0;
}
```

#### 二维数组数组名
  - 查看二维数组所占内存空间

  - 获取二维数组首地址

示例：

  ```cpp
  using namespace std;
  int main(){
    //查看占用内存空间大小
    int arr[2][3] = {
      {1,2,3},
      {4,5,6}
    };
    cout << "二维数组占用内存空间为：" << (sizeof(arr)) << endl;
    cout << "二维数组第一行占用内存空间为：" << sizeof(arr[0]) << endl; //arr[0]表示第一行
  
    //查看二维数组首地址
    cout << "二维数组首地址为：" << arr << endl;
  
    system("pause");
    return 0;
  }
  ```

数组的可以用来表示形象的，如二维数组可以很自然地表示地图；也可以表示抽象的，来存储、记录一些状态等，如在遍历图时开一个 $vis$ 数组记录这个节点是否走过，再如动态规划记录已经走过状态的最优解等。之后用到数组的地方非常多，可能不止一维、两维，更高维的数组以一维、两维数组类推即可。

